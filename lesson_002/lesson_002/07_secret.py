#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# есть зашифрованное сообщение

secret_message = [
    'квевтфпп6щ3стмзалтнмаршгб5длгуча',
    'дьсеы6лц2бане4т64ь4б3ущея6втщл6б',
    'т3пплвце1н3и2кд4лы12чф1ап3бкычаь',
    'ьд5фму3ежородт9г686буиимыкучшсал',
    'бсц59мегщ2лятьаьгенедыв9фк9ехб1а',
]

# ключ к расшифровке:
#   первое слово - 4-я буква
#   второе слово - буквы с 10 по 13, включительно
#   третье слово - буквы с 6 по 15, включительно, через одну
#   четвертое слово - буквы с 8 по 13, включительно, в обратном порядке
#   пятое слово - буквы с 17 по 21, включительно, в обратном порядке
#
# Требуется задать конкретные индексы, например secret_message[3][12:23:4]
# Если нужны вычисления и разные пробы - делайте это в консоли пайтона, тут нужен только результат


#first_message = secret_message['квевтфпп6щ3стмзалтнмаршгб5длгуча']

# secret_message[0][4]
# print(secret_message[0][4])
#
# secret_message[1][10:14]
# print(secret_message[1][10:14])
#
# secret_message[2][6:15:2]
# print(secret_message[2][6:16:2])
#
# secret_message[3][8:13:-1]
# print(secret_message[3][::-1][18:24])
#
# secret_message[4][::-1][17:21]
# print(secret_message[4][::-1][10:15])

print(secret_message[0][4], secret_message[1][10:14], secret_message[2][6:16:2], secret_message[3][::-1][18:24], secret_message[4][::-1][10:15])
#Сделал 4 и 5 сообщение, посчитав символы задом наперед, так как не выводился результат +
#Вадим Шандринов не показал в видео, как делать задом наперед в промежутке (если в 3 модуле покажет, то исправлю)
#Насколько понял должно было получиться сообщение "Танец дороже денег", но либо так и должно выйти, либо он что-то напутал

#TODO Объясни, как делать промежуток включительно, но задом наперед

# first_message = 'квевтфпп6щ3стмзалтнмаршгб5длгуча'[4]         # TODO: там написано 4ая буква. а Т - это пятая буква
# print(first_message)
# second_message = 'дьсеы6лц2бане4т64ь4б3ущея6втщл6б'[10:14]    # TODO: тут та же проблема: в условии говорят называют номера букв, а не индексы.
# print(second_message)                                         #       индексы самому надо посчитать на основе номеров
# third_message = 'т3пплвце1н3и2кд4лы12чф1ап3бкычаь'[6:16:2]
# print(third_message)
# fourth_message = 'ьд5фму3е жородт 9г686буиимыкучшсал'[::-1][8:14]
# print(fourth_message)
#fifth_message = 'бсц59мегщ2лятьаьг енеды в9фк9ехб1а'[::-1][17:21]


# TODO: Принцип работы индексов в срезах (кратко).
#  Пусть у нас есть строка S = "0123456789". Как работает срез:
#       S[5:] == '56789'        # левая граница показывает, начиная с какого символа (включительно), начинается срез.
#                               # т.е. правило получаем правило - "левая граица включительно, а правая - нет"
#       S[:5] == '01234'        # правая граница показывает по какой символ берется срез (НЕ включительно).
#  .
#  [0 1 2 3 4 5 6 7 8 9]        # вся строка S
#  [0 1 2 3 4]                  # срез S[:5] или же S[0:5]  (если срез начинается с 0, то 5 - число элементов в срезе)
#            [5 6 7 8 9].       # срез S[5:] или же S[5:10]
#  .
#  Поэтому сумма срезов S[:5] и S[5:] равна исходной строке S.



# TODO: Принцип работы отрицательных индексов в срезах (кратко).
#  [9 8 7 6 5 4 3 2 1 0]    # вся строка S[::-1]
#  [9 8 7]                  # срез S[-1:-4:-1]  (начиная с последнего (включительно) по 4ый (не включительно) с шагом -1
#                           # тот же результат даст срез S[9:6:-1], т.к. S[9] == S[-1] и S[6] == S[4]
#  PS: S[0] == S[-10]       # получить первый элемент
#      S[9] == S[-1]        # получить последний элемент
#  .
#  Таблица, описывающая примеры срезов: https://hsto.org/files/ef4/f9e/a20/ef4f9ea203604aadb56748e7305def0e.png




# TODO: для 2х последних слов.
#   В задании приведен пример: secret_message[3][12:23:4]
#       12 - это стартовая позиция, с которой начинаем;
#       23 - предел, до которой дойдем и остановимся, не касаясь ее; т.е. 22 - конечная;
#       4 - шаг, с которым мы будем шагать начиная от 13 до 23 буквы. Т.е. будут выведены 13, 17, 21 буквы.
#   .
#   Для secret_message[3][XXX:YYY:-1] нужно подобрать такие XXX и YYY, чтобы слово получалось одним срезом. Аналогично
#   для secret_message[4].



# TODO: начни с трех первых слов. В них положительный шаг. Поэтому чуть проще.
#  Отрицательный шаг и отрицательные индексы буду иногда всплывать, но то чтобы каждый программист тебе сходу скажет о том,
#  как начиная 9 до 3 символ вывести каждый второй символ. Т.е. нетривиальная задача, приходится поподбирать коэффициенты.
#  Но лучше не пальцем в небо тыкать, а приблизительно понимать что делаешь (сказанное касается отрицательного шага)
#  .
#  А для положтельного шага, да, надо понимать. И решив несколько задач, привыкнешь к ним, не будет такого страдания.
#  .
#  Еще один пункт: не путай НОМЕР и ИНДЕКС. Если в задаче написано "с 1го номера до конца с шагом 2",
#  значит в коде пишем "0::2" (по середине пропускаю число, т.о говоря что до конца)


# TODO: Вот например 4ое слово.
#  "четвертое слово - буквы с 8 по 13, включительно, в обратном порядке":
#    1234567890123...
#    ьд5фму3ежородт9г686буиимыкучшсал
#     ↑↑↑   ↑    ↑
#   первые  ↑    ↑
#   7 букв. ↑    ↑
#           ↑    ↑
#       8ая бук. ↑
#       (включ.).↑
#                ↑
#             13ая буква (включительно)
#  .
#  Задание описывает положение букв в порядке (не индексы, а номера букв!)

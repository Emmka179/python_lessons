#!/usr/bin/env python
# -*- coding: utf-8 -*-

# в саду сорвали цветы
garden = ('ромашка', 'роза', 'одуванчик', 'ромашка', 'гладиолус', 'подсолнух', 'роза', )

# на лугу сорвали цветы
meadow = ('клевер', 'одуванчик', 'ромашка', 'клевер', 'мак', 'одуванчик', 'ромашка', )

# создайте множество цветов, произрастающих в саду и на лугу
garden_set = set(garden)
meadow_set = set(meadow)


# выведите на консоль все виды цветов
flowers = list(garden_set | meadow_set)
print(flowers)

# выведите на консоль те, которые растут и там и там
flowers_both = list(garden_set & meadow_set)
print(flowers_both)

# выведите на консоль те, которые растут в саду, но не растут на лугу
flowers_garden = list(garden_set - meadow_set)
print(flowers_garden)

# выведите на консоль те, которые растут на лугу, но не растут в саду
flowers_meadow = list(meadow_set - garden_set)
print(flowers_meadow)

#8 task completed



# TODO: абсолютно правильно сделал, 1 раз создал 2 множества и дальше их используешь. Если бы цветов в списке было
#  по 1 млрд в каждом, то операция преобразования garden_set = set(garden) была бы очень тяжелой, и занимала пару сек.,
#  .
#  Плохой вариант (для контраста), это выполнение лишних операций по созданию множеств на каждом шаге:
#       print(set(garden) | set(meadow))        # так не делать, если переменную
#       print(set(garden) & set(meadow))        # нужно потом еще раз использовать!
#  .
#  В таком случае код работает медленнее, т.к. операция создания множеств повторяется на каждом шагу.
#  У вас все пучком) Для ознакомления написал.

# зачет!
# -*- coding: utf-8 -*-

# (цикл while)

# даны целые положительные числа a и b (a > b)
# Определить результат целочисленного деления a на b, с помощью цикла while,
# __НЕ__ используя стандартную операцию целочисленного деления (// и %)
# Формат вывода:
#   Целочисленное деление ХХХ на YYY дает ZZZ

#Сделал сам, только посмотрел, что такое += и -=
a, b = 179, 37
c = 0
while a >= b:
    a -= b
    c += 1
print('Целочисленное деление {} на {} дает {}'.format(a, b, c))
#Сделал сам, но посмотрел в инете функцию divmod, она работает так (результат, остаток)
a, b = 179, 37
while True:
    # TODO:
    #  По сути - это "хак задания", потом Вадим добавил в описание, что divmod тоже нельзя)) Но раз тут такого
    #  не написано - давай исследовать.  посмотри в доке как работает divmod.
    result = divmod(a, b)
    print('Целочисленное деление {} на {} дает {}, где 31 остаток'.format(a, b, result))
    break
# TODO: упрости 2ое решение по максимуму, при желании можно уместить в 3 строки, без потери читабельности
#Подглядел в инете, так как не понимал, как вместо 31 и 37 в первом варианте, вывести 179 на 37
#Теперь понял, что надо было создать еще одну переменную и вместо вычитания применить умножение
a, b = 179, 37
c = 0
d = 0
while d <= a:
    c += 1
    d = b * c
c -= 1
# TODO: format - вообще старый способ вывода, его щас редко используют. Больше применяй f-строки, они быстрее и легче
#  читаются.
print('Целочисленное деление {} на {} дает {}'.format(a, b, c))


# TODO: "надо было создать еще одну переменную" - это ключ к фиксу первой попытки. Оператор -= модифицируется переменную
#  а она нам нужна потом, нельзя переменную "а" править.
#  .
#  1. Скорректируй первую версию, чтобы заработала;
#  2. Во второй изучи divmod, оптимизируй и добейся вывода как в третье версии:
#       Целочисленное деление 179 на 37 дает (4, 31), где 31 остаток        - щас так
#       Целочисленное деление 179 на 37 дает 4.                             - а хотим так
#  3. Во всех 3х замени format на f-строку.
